#!/bin/bash

set -e

# normalize path
ROOT_PATH=${ROOT_PATH:-"/"}
# remove trailing slashes
ROOT_PATH=$(echo "${ROOT_PATH}" | sed -e "s/\/*$//")
# add a traingling slash
ROOT_PATH="${ROOT_PATH}/"

FW_REPO="https://github.com/cubieplayer/cubian-update.git"
FW_REPO_LOCAL="${ROOT_PATH}root/.cubian-update"
FW_MOD_PATH="${ROOT_PATH}lib/modules"
FW_REVISION=".update_revision"
FW_CURRENT_REV="${FW_REPO_LOCAL}/${FW_REVISION}"
GIT_CMD="git --git-dir=\"${FW_REPO_LOCAL}/.git\" --work-tree=\"${FW_REPO_LOCAL}\""

FSTAB="${ROOT_PATH}etc/fstab"

MMC_DEVICE="/dev/mmcblk0"
NAND_DEVICE="/dev/nand"

NAND1_DEVICE="/dev/nand1"
NANDA_DEVICE="/dev/nanda"

NAND_BOOT_PART=
NAND_BOOT_MOUNT_POINT="${ROOT_PATH}root/nand-bootloader"

NAME_UBOOT_BIN="u-boot.bin"
NAME_UENV_TXT="uEnv.txt"
NAME_SCRIPT_BIN="script.bin"

UBOOT_MMC_UPDATE="${FW_REPO_LOCAL}/u-boot-mmc.bin"
UBOOT_NAND_UPDATE="${FW_REPO_LOCAL}/u-boot-nand.bin"
SUNXI_SPL_UPDATE="${FW_REPO_LOCAL}/sunxi-spl.bin"
UENV_TXT_UPDATE="${FW_REPO_LOCAL}/boot/${NAME_UENV_TXT}"
SCRIPT_BIN_UPDATE="${FW_REPO_LOCAL}/boot/${NAME_SCRIPT_BIN}"

OPT_VERBOSE=false
OPT_REINSTALL=false
OPT_TEST=false
OPT_CLEAN=false
REVERT_FIRMWARE=false
OPT_SKIP_KERNEL=false
OPT_SKIP_MODULES=false

DOES_UPDATE_KERNEL=false
DOES_UPDATE_MODULES=false
DOES_UPDATE_BOOTLOADER=false

COLOR_NORMAL=$(echo -e "\033[m")
COLOR_BLUE=$(echo -e "\033[36m")
COLOR_GREEN=$(echo -e "\033[32m")
COLOR_YELLOW=$(echo -e "\033[33m")
COLOR_GRAY=$(echo -e "\033[37m")
COLOR_RED=$(echo -e "\033[31m")

SYS_INSTALL_TYPE_NAND="nand"
SYS_INSTALL_TYPE_MMC="mmc"

SYS_INSTALL_TYPE=

BRANCH_A10="a10"
BRANCH_A20="a20"
BRANCH=

usage(){
cat<<EOF
Usage: $0 options

This script will update your system files to latest version. It respects the
enviroment variable ROOT_PATH, it sets to '/' by default.

Options:
  -h,--help            Show this message
  -r,--reinstall       Perform reinstallation of the updates
  -v,--verbos          Verbose output
  -c,--clean           Clean up everything, redownload updates from server
     --revert-firmware Revert firmware to previous release. You may executes 
                       the revert command mutiple times in order to update the
                       firmware to historical versions
     --skip-kernel     Skip to update kernel
     --skip-modules    Skip to update modules
EOF
}

if ! OPTIONS=$(getopt -o hrvct -l help \
-l reinstall \
-l verbose \
-l clean \
-l revert \
-l revert-firmware \
-l skip-kernel \
-l skip-modules \
-- "$@");then
	usage
	exit 1
fi

set -- $OPTIONS

while [ $# -gt 0 ];do
	case $1 in
		-h|--help)
			usage
			exit 0
			;;
		-r|--reinstall)
			OPT_REINSTALL=true
			;;
		-v|--verbose) 
			OPT_VERBOSE=true
			;;
		-c|--clean) 
			OPT_CLEAN=true
			;;
		-t) 
			OPT_TEST=true
			;;
		--revert|--revert-firmware)
			REVERT_FIRMWARE=true
			;;
		--skip-kernel)
			OPT_SKIP_KERNEL=true
			;;
		--skip-modules)
			OPT_SKIP_MODULES=true
			;;
		(--) 
			shift; 
			break
			;;
		(-*) 
			echo "$0: error - unrecognized option $1" 1>&2
			exit 1
			;;
    	(*) 
			break
			;;
	esac
	shift
done

debug(){
	if $OPT_VERBOSE;then
		echo $1
	fi
}

backup(){
	opt="-f"
	if $OPT_VERBOSE;then
		opt="${opt}v"
	fi
	if [[ -d $1 ]];then
		opt="${opt}r"
	fi
	cp $opt $1 "$1.bak"
}

skipOpt2str(){
	if $1;then
		echo "no"
	else
		echo "yes"
	fi
}

bool2str(){
	if $1;then
		echo "yes"
	else
		echo "no"
	fi
}

checkRootPath(){
	if [[ ! -d ${ROOT_PATH}lib/modules ]] ||\
	   	[[ ! -d ${ROOT_PATH}boot ]] ||\
	   	[[ ! -f $FSTAB ]];then
		return 1
	fi
	return 0
}

determineBranchManually(){
while true;do
	read -p "${COLOR_YELLOW}What's your device type, a10 or a20?${COLOR_NORMAL}" given_branch
	case $given_branch in
		[aA]10) BRANCH="$BRANCH_A10";break;;
		[aA]20) BRANCH="$BRANCH_A20";break;;
		*) echo "Invalid device type. Please type a10 or a20."
	esac
done
}

determineBranch(){
	set +e
	if [[ "$ROOT_PATH" = "/" ]];then
		uname -r | grep 'sun7i\|3.3.0+' > /dev/null 2>&1 && \
		BRANCH="$BRANCH_A20" || \
		BRANCH="$BRANCH_A10"
	else
		determineBranchManually
	fi
	set -e
}

determineSysInstallType(){
	set +e
	cat $FSTAB | awk '{if($2=="/") {print $1}}' | grep $MMC_DEVICE > /dev/null 2>&1 && \
		SYS_INSTALL_TYPE="$SYS_INSTALL_TYPE_MMC"
	if [[ -z $SYS_INSTALL_TYPE ]];then
		cat $FSTAB | awk '{if($2=="/") {print $1}}' | grep $NAND_DEVICE > /dev/null 2>&1 && \
		SYS_INSTALL_TYPE="$SYS_INSTALL_TYPE_NAND"
	fi
	set -e
}

echoBlue(){
	echo "${COLOR_BLUE}${1}${COLOR_NORMAL}"
}
echoRed(){
	echo "${COLOR_RED}${1}${COLOR_NORMAL}"
}

echoGreen(){
	echo "${COLOR_GREEN}${1}${COLOR_NORMAL}"
}

downloadFirmwareRepo(){
	echoBlue "*** Downloading firmware (this may take a while)"
	mkdir -p "${FW_REPO_LOCAL}"
	set +e
	if $OPT_VERBOSE;then
		git clone "${FW_REPO}" "${FW_REPO_LOCAL}" --branch ${BRANCH}
	else
		git clone "${FW_REPO}" "${FW_REPO_LOCAL}" --branch ${BRANCH} > /dev/null 2>&1
	fi
	RETVAL=$?
	set -e
	if [[ ${RETVAL} -ne 0 ]]; then
		echoRed "!!! Failed to download firmware,Please check internet connection"
		exit 1
	fi
}

forceCleanupRepo(){
	debug "clean up repository"
	if $OPT_VERBOSE;then
		eval ${GIT_CMD} checkout .
		eval ${GIT_CMD} clean -dfxe ${FW_REVISION}
	else
		eval ${GIT_CMD} checkout -q  .
		eval ${GIT_CMD} clean -qdfxe ${FW_REVISION}
	fi
}

# update repository to lastest then checkout a specific tag
updateFirmwareRepo(){
	echoBlue "*** Downloading updates (this may take a while)"

	forceCleanupRepo

	branch_name=$(eval ${GIT_CMD} rev-parse --abbrev-ref HEAD)
	if [[ "$BRANCH" != "$branch_name" ]];then
		if $OPT_VERBOSE;then
			eval ${GIT_CMD} checkout $BRANCH
		else
			eval ${GIT_CMD} checkout $BRANCH > /dev/null 2>&1
		fi
	fi
	if $OPT_VERBOSE;then
		eval ${GIT_CMD} pull -v origin
	else
		eval ${GIT_CMD} pull -q origin > /dev/null 2>&1
	fi
}

updateKernel(){
	echoBlue "*** Updating kernel"
	if $OPT_VERBOSE;then
		echo -n "${COLOR_GRAY}"
		cp -v "${FW_REPO_LOCAL}/boot/uImage" "${ROOT_PATH}boot"
		echo -n "${NORMAL}"
	else
		cp "${FW_REPO_LOCAL}/boot/uImage" "${ROOT_PATH}boot"
	fi
    DOES_UPDATE_KERNEL=true
}

updateModules(){
	echoBlue "*** Updating modules"
	if $OPT_VERBOSE;then
		echo -n "${COLOR_GRAY}"
		cp -vR "${FW_REPO_LOCAL}/modules/"* "${FW_MOD_PATH}/"
		echo -n "${NORMAL}"
	else
		cp -R "${FW_REPO_LOCAL}/modules/"* "${FW_MOD_PATH}/"
	fi
	find "${FW_REPO_LOCAL}/modules" -mindepth 1 -maxdepth 1 -type d | while read DIR; do
			echoBlue "*** Depmod $(basename "${DIR}")"
			depmod -b "${ROOT_PATH}" -a $(basename "${DIR}")
	done
	DOES_UPDATE_MODULES=true
}

acquireMMCDevice(){
while true;do
	read -p "${COLOR_YELLOW}Please type in your SD-device(eg. /dev/sdb).${COLOR_NORMAL}" given_device
	case $given_device in
		*)
			if [[ -b $given_device ]];then
				MMC_DEVICE="$given_device"
				break;
			elif [[ -z $given_device ]];then
				echo "device can not be empty"
			else
				echo "$given_device is not valid block device"
			fi
			;;
	esac
done
}

updateBootLoaderMMC(){
	echoBlue "*** Updating bootloader on SD-Card"
	if [[ -f $UBOOT_MMC_UPDATE ]];then
		if $OPT_VERBOSE;then
			debug "Write u-boot to SD-Card"
			dd if=$UBOOT_MMC_UPDATE of=$MMC_DEVICE bs=1024 seek=32
		else
			dd if=$UBOOT_MMC_UPDATE of=$MMC_DEVICE bs=1024 seek=32 > /dev/null 2>&1
		fi
	fi
	if [[ -f $SUNXI_SPL_UPDATE ]];then
		if $OPT_VERBOSE;then
			debug "Write sunxi-spl to SD-Card"
			dd if=$SUNXI_SPL_UPDATE of=$MMC_DEVICE bs=1024 seek=8
		else
			dd if=$SUNXI_SPL_UPDATE of=$MMC_DEVICE bs=1024 seek=8 > /dev/null 2>&1
		fi
	fi
	DOES_UPDATE_BOOTLOADER=true
}

updateBootLoaderNAND(){
	echoBlue "*** Updating bootloader on NAND"

	mkdir -p $NAND_BOOT_MOUNT_POINT

	if [[ -b $NAND1_DEVICE ]];then
		mount $NAND1_DEVICE $NAND_BOOT_MOUNT_POINT
	elif [[ -b $NANDA_DEVICE ]];then
		mount $NANDA_DEVICE $NAND_BOOT_MOUNT_POINT
	fi

	if [[ -f $UBOOT_NAND_UPDATE ]];then
		uboot_nand_dest=$(find $NAND_BOOT_MOUNT_POINT -name "$NAME_UBOOT_BIN")
		
		if $OPT_VERBOSE;then
			debug "Overwrite u-boot to on nand boot partition"
			cp -v $UBOOT_NAND_UPDATE $uboot_nand_dest
		else
			cp $UBOOT_NAND_UPDATE $uboot_nand_dest
		fi
	fi

	if [[ -f $UENV_TXT_UPDATE ]];then
		uenv_txt_dest="${ROOT_PATH}boot/${NAME_UENV_TXT}"
		backup $uenv_txt_dest
		if $OPT_VERBOSE;then
			debug "Update uEnv.txt"
			cp -v $UENV_TXT_UPDATE $uenv_txt_dest
		else
			cp $UENV_TXT_UPDATE $uenv_txt_dest
		fi
	fi

	umount -l $NAND_BOOT_MOUNT_POINT

	rm -rf $NAND_BOOT_MOUNT_POINT

	DOES_UPDATE_BOOTLOADER=true
}

updateFirmware(){
	echoBlue "*** Updating firmware"
	if [[ -z "$1" ]];then
		# which is the latest tag
		tagname=$(eval ${GIT_CMD} tag -l ${BRANCH}* | tail -n 1)
		if $OPT_VERBOSE;then
			debug "Using tag $tagname which is latest in local repository"
		fi
	else
		tagname="$1"
		if $OPT_VERBOSE;then
			debug "As requested using tag $tagname from local repository"
		fi
	fi

	forceCleanupRepo

	if $OPT_VERBOSE;then
		eval ${GIT_CMD} checkout tags/${tagname}
	else
		eval ${GIT_CMD} checkout tags/${tagname} > /dev/null 2>&1
	fi

	if ! $OPT_SKIP_KERNEL;then
		updateKernel
	else
		echoBlue "*** As requested, not updating kernel"
	fi
	if ! $OPT_SKIP_MODULES;then
		updateModules
	else
		echoBlue "*** As requested, not updating modules"
	fi

	if [[ -b $MMC_DEVICE ]] && \
		[[ "$SYS_INSTALL_TYPE" = "$SYS_INSTALL_TYPE_MMC" ]] && \
		([[ -f $UBOOT_MMC_UPDATE ]] || [[ -f $SUNXI_SPL_UPDATE ]]);then
		updateBootLoaderMMC
	elif [[ -b $NAND_DEVICE ]] && \
		[[ "$SYS_INSTALL_TYPE" = "$SYS_INSTALL_TYPE_NAND" ]] && \
		([[ -f $UBOOT_NAND_UPDATE ]] || [[ -f $UENV_TXT_UPDATE ]]);then
		updateBootLoaderNAND
	elif [[ ! -b $MMC_DEVICE ]] && \
		[[ "$ROOT_PATH" != "/" ]] && \
		[[ "$SYS_INSTALL_TYPE" = "$SYS_INSTALL_TYPE_MMC" ]] && \
		([[ -f $UBOOT_MMC_UPDATE ]] || [[ -f $SUNXI_SPL_UPDATE ]]);then
		# ask user for MMC device
		acquireMMCDevice
		updateBootLoaderMMC
	else
		echoRed "warning: failed to update bootloader"
	fi

	if [[ -f $SCRIPT_BIN_UPDATE ]];then
		script_bin_dest="${ROOT_PATH}boot/${NAME_SCRIPT_BIN}"
		backup $script_bin_dest
		if $OPT_VERBOSE;then
			debug "update script.bin"
			cp -v $SCRIPT_BIN_UPDATE $script_bin_dest
		else
			cp $SCRIPT_BIN_UPDATE $script_bin_dest
		fi
	fi

	if $DOES_UPDATE_KERNEL || $DOES_UPDATE_BOOTLOADER;then
		echoGreen "*** Update success, A reboot is needed for changes to take effects"
	fi

	echo "$tagname" > "${FW_CURRENT_REV}"
}

installUpdates(){
	echoGreen "*** Checking updates from server"
	debug "Checking updates from server ${FW_REPO}"

	# get latest tag from remote
	if [[ "$BRANCH" = "$BRANCH_A10" ]];then
		fw_remote_tag=$(git ls-remote --tags ${FW_REPO} refs/tags/${BRANCH}*[^}] | awk '{print $2}' | sort -n | tail -n 1 | cut -c 11-)
	elif [[ "$BRANCH" = "$BRANCH_A20" ]];then
		fw_remote_tag=$(git ls-remote --tags ${FW_REPO} refs/tags/${BRANCH}*[^}] | awk '{print $2}' | sort -n | tail -n 1 | cut -c 11-)
	fi

	if [[ -z $fw_remote_tag ]];then
		echoRed "error: fail to fetch update information"
		exit 1
	fi

	fw_local_tag=$(cat "${FW_CURRENT_REV}")

	debug "Remote revision: ${fw_remote_tag}"
	debug "Local revision: ${fw_local_tag}"

	if [[ "$fw_local_tag" == "$fw_remote_tag" ]]; then
		echoGreen "*** Your firmware is up to date"
	else
		updateFirmwareRepo 
		updateFirmware $fw_remote_tag
	fi
}

# main
if [[ ${EUID} -ne 0 ]]; then
	echoRed "!!! This tool must be run as root"
	exit 1
fi

#echoBlue "*** Cubian updater"

if ! checkRootPath;then
	echoRed "error: can't update, please correct ROOT_PATH. The current value is $ROOT_PATH"
	exit
fi

if $OPT_TEST;then
	FW_REPO="https://github.com/mmplayer/cubian-update.git"
fi

if $OPT_CLEAN;then
	echoBlue "*** Perform clean"
	if $OPT_VERBOSE;then
		rm -rfv $FW_REPO_LOCAL
	else
		rm -rf $FW_REPO_LOCAL
	fi
	echoGreen "*** Clean success"
	exit 0
fi

debug "Update From: ${FW_REPO}"
debug "Root Path: ${ROOT_PATH}"
debug "Update Kernel: $(skipOpt2str ${OPT_SKIP_KERNEL})"
debug "Update Modules: $(skipOpt2str ${OPT_SKIP_MODULES})"

determineBranch
if [[ -z $BRANCH ]];then
	echoRed "error: can't update, failed to detect device type"
	exit
fi
debug "Branch: $BRANCH"

determineSysInstallType
if [[ -z $SYS_INSTALL_TYPE ]];then
	echoRed "error: can't update, failed to detect system type"
	exit
fi
debug "SysInstallType: $SYS_INSTALL_TYPE"

if [[ ! -f "${FW_REPO_LOCAL}/.git/config" ]];then
	downloadFirmwareRepo
fi

if $REVERT_FIRMWARE;then
	# revert to previous tag based on current tag
	if [[ ! -f ${FW_CURRENT_REV} ]];then
		echoRed "*** Revert firmware failed, missing file ${FW_CURRENT_REV}, try again with --reinstall then revert"
		exit 2
	fi
	current_tagname=$(cat "${FW_CURRENT_REV}")
	previous_tagname=$(eval ${GIT_CMD} tag -l ${BRANCH}* | awk '{if($1==current_tag){print p};p=$1}' current_tag=$current_tagname)
	if [[ -z $previous_tagname ]];then
		echoRed "*** Revert firmware failed, reached the oldest version"
		exit 2
	else
		updateFirmware $previous_tagname
	fi
	exit 0
fi

if [[ ! -f "${FW_CURRENT_REV}" ]];then
	updateFirmware
	# provide reinstall flag but never installed, give a reinstall feedback
	if $OPT_REINSTALL;then
		echoGreen "*** Reinstall success"
		exit 0
	fi
else
	# perform reinstall
	if $OPT_REINSTALL;then
		current_tagname=$(cat "${FW_CURRENT_REV}")
		updateFirmware $current_tagname
		echoGreen "*** Reinstall success"
		exit 0
	fi
	installUpdates
fi
exit 0
